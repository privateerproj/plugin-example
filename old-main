package main

import (
	"flag"
	"fmt"
	"io"
	"os"

	"github.com/privateerproj/privateer-pack-wireframe/internal/config"
	"github.com/privateerproj/privateer-pack-wireframe/pack"

	"github.com/privateerproj/privateer-sdk/command"
	"github.com/privateerproj/privateer-sdk/plugin"
	"github.com/privateerproj/privateer-sdk/raidengine"
)

var (
	// RaidName is the name for the service pack
	// TODO: Return binary name instead? Or add this to the interface to use instead of the binary name?
	RaidName = "Wireframe"

	// Version is the main version number that is being run at the moment
	Version = "0.1.0"

	// Prerelease is a marker for the version. If this is "" (empty string)
	// then it means that it is a final release. Otherwise, this is a pre-release
	// such as "dev" (in development), "beta", "rc", etc.
	// This should only be modified thru ldflags in make file. See 'make release'
	Prerelease = "dev"

	// GitCommitHash references the commit id at build time
	// This should only be modified thru ldflags in make file. See 'make release'
	GitCommitHash = ""

	// BuiltAt is the build date
	// This should only be modified thru ldflags in make file. See 'make release'
	BuiltAt = ""
)

// Raid ...
type Raid struct {
	RaidName string
}

// Start is required to meet the Privateer Service Pack interface
func (sp *Raid) Start() error {
	// raidengine.SetupCloseHandler(sigtermProtection)

	return raidengine.Run(RaidName, pack.Policies) // TODO handle these errors
}

// main is executed when this file is called as a binary or `go run`
func main() {
	versionCmd, runCmd := setFlags()
	command.InitializeConfig()
	handleCommands(versionCmd, runCmd)
}

func setFlags() (versionCmd, runCmd *flag.FlagSet) {
	// > privateer version [-v]
	versionCmd = flag.NewFlagSet("version", flag.ExitOnError)
	config.Vars.Verbose = *versionCmd.Bool("v", false, "Display extended version information") // TODO: Harness '-v' in the standard privateer execution

	// > privateer
	runCmd = flag.NewFlagSet("run", flag.ExitOnError)
	runCmd.StringVar(&config.Vars.VarsFile, "varsfile", "", "path to config file")
	return
}

func handleCommands(versionCmd, runCmd *flag.FlagSet) {
	subCommand := ""
	if len(os.Args) > 1 {
		subCommand = os.Args[1]
	}
	switch subCommand {
	case "version":
		versionCmd.Parse(os.Args[2:])
		printVersion(os.Stdout)

	case "debug": // Same cli args as run. Use this to bypass plugin and execute directly for debugging
		// Parse cli args
		runCmd.Parse(os.Args[2:]) // Skip first arg as it will be 'debug'
		raidengine.Run(RaidName, pack.Policies)

	default:
		// Parse cli args
		runCmd.Parse(os.Args[1:])

		// Serve plugin
		raid := &Raid{}
		serveOpts := &plugin.ServeOpts{
			Plugin: raid,
		}

		plugin.Serve(serveOpts)
	}
}

// Cleanup any test resources that were created during execution
// func sigtermProtection() error {
// 	return nil
// }

// TODO: move version info to a trace log during raidengine.Run
func printVersion(w io.Writer) {

	if config.Vars.Verbose {
		fmt.Fprintf(w, "Service Pack : %s", RaidName)
		fmt.Fprintln(w)
		fmt.Fprintf(w, "Version      : %s", getVersion())
		fmt.Fprintln(w)
		fmt.Fprintf(w, "Commit       : %s", GitCommitHash)
		fmt.Fprintln(w)
		fmt.Fprintf(w, "Built at     : %s", BuiltAt)
	} else {
		fmt.Fprintf(w, "Version      : %s", getVersion())
	}
}

func getVersion() string {
	if Prerelease != "" {
		return fmt.Sprintf("%s-%s", Version, Prerelease)
	}
	return Version
}
